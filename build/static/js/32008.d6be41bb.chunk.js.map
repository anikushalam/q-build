{"version":3,"file":"static/js/32008.d6be41bb.chunk.js","mappings":"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","sources":["../node_modules/@mui/icons-material/Crop.js","../node_modules/@mui/icons-material/esm/Cancel.js","../node_modules/number-to-words/numberToWords.min.js","../node_modules/react-circular-progressbar/src/constants.ts","../node_modules/react-circular-progressbar/src/Path.tsx","../node_modules/react-circular-progressbar/src/CircularProgressbar.tsx","../node_modules/src/observe.ts","../node_modules/src/InView.tsx","../node_modules/src/useInView.tsx"],"sourcesContent":["\"use strict\";\n\"use client\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _createSvgIcon = _interopRequireDefault(require(\"./utils/createSvgIcon\"));\nvar _jsxRuntime = require(\"react/jsx-runtime\");\nvar _default = (0, _createSvgIcon.default)( /*#__PURE__*/(0, _jsxRuntime.jsx)(\"path\", {\n  d: \"M17 15h2V7c0-1.1-.9-2-2-2H9v2h8v8zM7 17V1H5v4H1v2h4v10c0 1.1.9 2 2 2h10v4h2v-4h4v-2H7z\"\n}), 'Crop');\nexports.default = _default;","\"use client\";\n\nimport createSvgIcon from './utils/createSvgIcon';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon( /*#__PURE__*/_jsx(\"path\", {\n  d: \"M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z\"\n}), 'Cancel');","/*!\n * Number-To-Words util\n * @version v1.2.4\n * @link https://github.com/marlun78/number-to-words\n * @author Martin Eneqvist (https://github.com/marlun78)\n * @contributors Aleksey Pilyugin (https://github.com/pilyugin),Jeremiah Hall (https://github.com/jeremiahrhall),Adriano Melo (https://github.com/adrianomelo),dmrzn (https://github.com/dmrzn)\n * @license MIT\n */\n!function(){\"use strict\";var e=\"object\"==typeof self&&self.self===self&&self||\"object\"==typeof global&&global.global===global&&global||this,t=9007199254740991;function f(e){return!(\"number\"!=typeof e||e!=e||e===1/0||e===-1/0)}function l(e){return\"number\"==typeof e&&Math.abs(e)<=t}var n=/(hundred|thousand|(m|b|tr|quadr)illion)$/,r=/teen$/,o=/y$/,i=/(zero|one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve)$/,s={zero:\"zeroth\",one:\"first\",two:\"second\",three:\"third\",four:\"fourth\",five:\"fifth\",six:\"sixth\",seven:\"seventh\",eight:\"eighth\",nine:\"ninth\",ten:\"tenth\",eleven:\"eleventh\",twelve:\"twelfth\"};function h(e){return n.test(e)||r.test(e)?e+\"th\":o.test(e)?e.replace(o,\"ieth\"):i.test(e)?e.replace(i,a):e}function a(e,t){return s[t]}var u=10,d=100,p=1e3,v=1e6,b=1e9,y=1e12,c=1e15,g=9007199254740992,m=[\"zero\",\"one\",\"two\",\"three\",\"four\",\"five\",\"six\",\"seven\",\"eight\",\"nine\",\"ten\",\"eleven\",\"twelve\",\"thirteen\",\"fourteen\",\"fifteen\",\"sixteen\",\"seventeen\",\"eighteen\",\"nineteen\"],w=[\"zero\",\"ten\",\"twenty\",\"thirty\",\"forty\",\"fifty\",\"sixty\",\"seventy\",\"eighty\",\"ninety\"];function x(e,t){var n,r=parseInt(e,10);if(!f(r))throw new TypeError(\"Not a finite number: \"+e+\" (\"+typeof e+\")\");if(!l(r))throw new RangeError(\"Input is not a safe number, it’s either too large or too small.\");return n=function e(t){var n,r,o=arguments[1];if(0===t)return o?o.join(\" \").replace(/,$/,\"\"):\"zero\";o||(o=[]);t<0&&(o.push(\"minus\"),t=Math.abs(t));t<20?(n=0,r=m[t]):t<d?(n=t%u,r=w[Math.floor(t/u)],n&&(r+=\"-\"+m[n],n=0)):t<p?(n=t%d,r=e(Math.floor(t/d))+\" hundred\"):t<v?(n=t%p,r=e(Math.floor(t/p))+\" thousand,\"):t<b?(n=t%v,r=e(Math.floor(t/v))+\" million,\"):t<y?(n=t%b,r=e(Math.floor(t/b))+\" billion,\"):t<c?(n=t%y,r=e(Math.floor(t/y))+\" trillion,\"):t<=g&&(n=t%c,r=e(Math.floor(t/c))+\" quadrillion,\");o.push(r);return e(n,o)}(r),t?h(n):n}var M={toOrdinal:function(e){var t=parseInt(e,10);if(!f(t))throw new TypeError(\"Not a finite number: \"+e+\" (\"+typeof e+\")\");if(!l(t))throw new RangeError(\"Input is not a safe number, it’s either too large or too small.\");var n=String(t),r=Math.abs(t%100),o=11<=r&&r<=13,i=n.charAt(n.length-1);return n+(o?\"th\":\"1\"===i?\"st\":\"2\"===i?\"nd\":\"3\"===i?\"rd\":\"th\")},toWords:x,toWordsOrdinal:function(e){return h(x(e))}};\"undefined\"!=typeof exports?(\"undefined\"!=typeof module&&module.exports&&(exports=module.exports=M),exports.numberToWords=M):e.numberToWords=M}();","export const VIEWBOX_WIDTH = 100;\nexport const VIEWBOX_HEIGHT = 100;\nexport const VIEWBOX_HEIGHT_HALF = 50;\nexport const VIEWBOX_CENTER_X = 50;\nexport const VIEWBOX_CENTER_Y = 50;\n","import * as React from 'react';\nimport { VIEWBOX_CENTER_X, VIEWBOX_CENTER_Y } from './constants';\n\nfunction Path({\n  className,\n  counterClockwise,\n  dashRatio,\n  pathRadius,\n  strokeWidth,\n  style,\n}: {\n  className?: string;\n  counterClockwise: boolean;\n  dashRatio: number;\n  pathRadius: number;\n  strokeWidth: number;\n  style?: object;\n}) {\n  return (\n    <path\n      className={className}\n      style={Object.assign({}, style, getDashStyle({ pathRadius, dashRatio, counterClockwise }))}\n      d={getPathDescription({\n        pathRadius,\n        counterClockwise,\n      })}\n      strokeWidth={strokeWidth}\n      fillOpacity={0}\n    />\n  );\n}\n\n// SVG path description specifies how the path should be drawn\nfunction getPathDescription({\n  pathRadius,\n  counterClockwise,\n}: {\n  pathRadius: number;\n  counterClockwise: boolean;\n}) {\n  const radius = pathRadius;\n  const rotation = counterClockwise ? 1 : 0;\n\n  // Move to center of canvas\n  // Relative move to top canvas\n  // Relative arc to bottom of canvas\n  // Relative arc to top of canvas\n  return `\n      M ${VIEWBOX_CENTER_X},${VIEWBOX_CENTER_Y}\n      m 0,-${radius}\n      a ${radius},${radius} ${rotation} 1 1 0,${2 * radius}\n      a ${radius},${radius} ${rotation} 1 1 0,-${2 * radius}\n    `;\n}\n\nfunction getDashStyle({\n  counterClockwise,\n  dashRatio,\n  pathRadius,\n}: {\n  counterClockwise: boolean;\n  dashRatio: number;\n  pathRadius: number;\n}) {\n  const diameter = Math.PI * 2 * pathRadius;\n  const gapLength = (1 - dashRatio) * diameter;\n\n  return {\n    // Have dash be full diameter, and gap be full diameter\n    strokeDasharray: `${diameter}px ${diameter}px`,\n    // Shift dash backward by gapLength, so gap starts appearing at correct distance\n    strokeDashoffset: `${counterClockwise ? -gapLength : gapLength}px`,\n  };\n}\n\nexport default Path;\n","import * as React from 'react';\n\nimport {\n  VIEWBOX_WIDTH,\n  VIEWBOX_HEIGHT,\n  VIEWBOX_HEIGHT_HALF,\n  VIEWBOX_CENTER_X,\n  VIEWBOX_CENTER_Y,\n} from './constants';\nimport Path from './Path';\nimport { CircularProgressbarDefaultProps, CircularProgressbarProps } from './types';\n\nclass CircularProgressbar extends React.Component<CircularProgressbarProps> {\n  static defaultProps: CircularProgressbarDefaultProps = {\n    background: false,\n    backgroundPadding: 0,\n    circleRatio: 1,\n    classes: {\n      root: 'CircularProgressbar',\n      trail: 'CircularProgressbar-trail',\n      path: 'CircularProgressbar-path',\n      text: 'CircularProgressbar-text',\n      background: 'CircularProgressbar-background',\n    },\n    counterClockwise: false,\n    className: '',\n    maxValue: 100,\n    minValue: 0,\n    strokeWidth: 8,\n    styles: {\n      root: {},\n      trail: {},\n      path: {},\n      text: {},\n      background: {},\n    },\n    text: '',\n  };\n\n  getBackgroundPadding() {\n    if (!this.props.background) {\n      // Don't add padding if not displaying background\n      return 0;\n    }\n    return this.props.backgroundPadding;\n  }\n\n  getPathRadius() {\n    // The radius of the path is defined to be in the middle, so in order for the path to\n    // fit perfectly inside the 100x100 viewBox, need to subtract half the strokeWidth\n    return VIEWBOX_HEIGHT_HALF - this.props.strokeWidth / 2 - this.getBackgroundPadding();\n  }\n\n  // Ratio of path length to trail length, as a value between 0 and 1\n  getPathRatio() {\n    const { value, minValue, maxValue } = this.props;\n    const boundedValue = Math.min(Math.max(value, minValue), maxValue);\n    return (boundedValue - minValue) / (maxValue - minValue);\n  }\n\n  render() {\n    const {\n      circleRatio,\n      className,\n      classes,\n      counterClockwise,\n      styles,\n      strokeWidth,\n      text,\n    } = this.props;\n\n    const pathRadius = this.getPathRadius();\n    const pathRatio = this.getPathRatio();\n\n    return (\n      <svg\n        className={`${classes.root} ${className}`}\n        style={styles.root}\n        viewBox={`0 0 ${VIEWBOX_WIDTH} ${VIEWBOX_HEIGHT}`}\n        data-test-id=\"CircularProgressbar\"\n      >\n        {this.props.background ? (\n          <circle\n            className={classes.background}\n            style={styles.background}\n            cx={VIEWBOX_CENTER_X}\n            cy={VIEWBOX_CENTER_Y}\n            r={VIEWBOX_HEIGHT_HALF}\n          />\n        ) : null}\n\n        <Path\n          className={classes.trail}\n          counterClockwise={counterClockwise}\n          dashRatio={circleRatio}\n          pathRadius={pathRadius}\n          strokeWidth={strokeWidth}\n          style={styles.trail}\n        />\n\n        <Path\n          className={classes.path}\n          counterClockwise={counterClockwise}\n          dashRatio={pathRatio * circleRatio}\n          pathRadius={pathRadius}\n          strokeWidth={strokeWidth}\n          style={styles.path}\n        />\n\n        {text ? (\n          <text\n            className={classes.text}\n            style={styles.text}\n            x={VIEWBOX_CENTER_X}\n            y={VIEWBOX_CENTER_Y}\n          >\n            {text}\n          </text>\n        ) : null}\n      </svg>\n    );\n  }\n}\n\nexport default CircularProgressbar;\n","import type { ObserverInstanceCallback } from './index';\n\nconst observerMap = new Map<\n  string,\n  {\n    id: string;\n    observer: IntersectionObserver;\n    elements: Map<Element, Array<ObserverInstanceCallback>>;\n  }\n>();\n\nconst RootIds: WeakMap<Element | Document, string> = new WeakMap();\nlet rootId = 0;\n\nlet unsupportedValue: boolean | undefined = undefined;\n\n/**\n * What should be the default behavior if the IntersectionObserver is unsupported?\n * Ideally the polyfill has been loaded, you can have the following happen:\n * - `undefined`: Throw an error\n * - `true` or `false`: Set the `inView` value to this regardless of intersection state\n * **/\nexport function defaultFallbackInView(inView: boolean | undefined) {\n  unsupportedValue = inView;\n}\n\n/**\n * Generate a unique ID for the root element\n * @param root\n */\nfunction getRootId(root: IntersectionObserverInit['root']) {\n  if (!root) return '0';\n  if (RootIds.has(root)) return RootIds.get(root);\n  rootId += 1;\n  RootIds.set(root, rootId.toString());\n  return RootIds.get(root);\n}\n\n/**\n * Convert the options to a string Id, based on the values.\n * Ensures we can reuse the same observer when observing elements with the same options.\n * @param options\n */\nexport function optionsToId(options: IntersectionObserverInit) {\n  return Object.keys(options)\n    .sort()\n    .filter(\n      (key) => options[key as keyof IntersectionObserverInit] !== undefined,\n    )\n    .map((key) => {\n      return `${key}_${\n        key === 'root'\n          ? getRootId(options.root)\n          : options[key as keyof IntersectionObserverInit]\n      }`;\n    })\n    .toString();\n}\n\nfunction createObserver(options: IntersectionObserverInit) {\n  // Create a unique ID for this observer instance, based on the root, root margin and threshold.\n  let id = optionsToId(options);\n  let instance = observerMap.get(id);\n\n  if (!instance) {\n    // Create a map of elements this observer is going to observe. Each element has a list of callbacks that should be triggered, once it comes into view.\n    const elements = new Map<Element, Array<ObserverInstanceCallback>>();\n    let thresholds: number[] | readonly number[];\n\n    const observer = new IntersectionObserver((entries) => {\n      entries.forEach((entry) => {\n        // While it would be nice if you could just look at isIntersecting to determine if the component is inside the viewport, browsers can't agree on how to use it.\n        // -Firefox ignores `threshold` when considering `isIntersecting`, so it will never be false again if `threshold` is > 0\n        const inView =\n          entry.isIntersecting &&\n          thresholds.some((threshold) => entry.intersectionRatio >= threshold);\n\n        // @ts-ignore support IntersectionObserver v2\n        if (options.trackVisibility && typeof entry.isVisible === 'undefined') {\n          // The browser doesn't support Intersection Observer v2, falling back to v1 behavior.\n          // @ts-ignore\n          entry.isVisible = inView;\n        }\n\n        elements.get(entry.target)?.forEach((callback) => {\n          callback(inView, entry);\n        });\n      });\n    }, options);\n\n    // Ensure we have a valid thresholds array. If not, use the threshold from the options\n    thresholds =\n      observer.thresholds ||\n      (Array.isArray(options.threshold)\n        ? options.threshold\n        : [options.threshold || 0]);\n\n    instance = {\n      id,\n      observer,\n      elements,\n    };\n\n    observerMap.set(id, instance);\n  }\n\n  return instance;\n}\n\n/**\n * @param element - DOM Element to observe\n * @param callback - Callback function to trigger when intersection status changes\n * @param options - Intersection Observer options\n * @param fallbackInView - Fallback inView value.\n * @return Function - Cleanup function that should be triggered to unregister the observer\n */\nexport function observe(\n  element: Element,\n  callback: ObserverInstanceCallback,\n  options: IntersectionObserverInit = {},\n  fallbackInView = unsupportedValue,\n) {\n  if (\n    typeof window.IntersectionObserver === 'undefined' &&\n    fallbackInView !== undefined\n  ) {\n    const bounds = element.getBoundingClientRect();\n    callback(fallbackInView, {\n      isIntersecting: fallbackInView,\n      target: element,\n      intersectionRatio:\n        typeof options.threshold === 'number' ? options.threshold : 0,\n      time: 0,\n      boundingClientRect: bounds,\n      intersectionRect: bounds,\n      rootBounds: bounds,\n    });\n    return () => {\n      // Nothing to cleanup\n    };\n  }\n  // An observer with the same options can be reused, so lets use this fact\n  const { id, observer, elements } = createObserver(options);\n\n  // Register the callback listener for this element\n  let callbacks = elements.get(element) || [];\n  if (!elements.has(element)) {\n    elements.set(element, callbacks);\n  }\n\n  callbacks.push(callback);\n  observer.observe(element);\n\n  return function unobserve() {\n    // Remove the callback from the callback list\n    callbacks.splice(callbacks.indexOf(callback), 1);\n\n    if (callbacks.length === 0) {\n      // No more callback exists for element, so destroy it\n      elements.delete(element);\n      observer.unobserve(element);\n    }\n\n    if (elements.size === 0) {\n      // No more elements are being observer by this instance, so destroy it\n      observer.disconnect();\n      observerMap.delete(id);\n    }\n  };\n}\n","import * as React from 'react';\nimport type { IntersectionObserverProps, PlainChildrenProps } from './index';\nimport { observe } from './observe';\n\ntype State = {\n  inView: boolean;\n  entry?: IntersectionObserverEntry;\n};\n\nfunction isPlainChildren(\n  props: IntersectionObserverProps | PlainChildrenProps,\n): props is PlainChildrenProps {\n  return typeof props.children !== 'function';\n}\n\n/**\n ## Render props\n\n To use the `<InView>` component, you pass it a function. It will be called\n whenever the state changes, with the new value of `inView`. In addition to the\n `inView` prop, children also receive a `ref` that should be set on the\n containing DOM element. This is the element that the IntersectionObserver will\n monitor.\n\n If you need it, you can also access the\n [`IntersectionObserverEntry`](https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry)\n on `entry`, giving you access to all the details about the current intersection\n state.\n\n ```jsx\n import { InView } from 'react-intersection-observer';\n\n const Component = () => (\n <InView>\n {({ inView, ref, entry }) => (\n      <div ref={ref}>\n        <h2>{`Header inside viewport ${inView}.`}</h2>\n      </div>\n    )}\n </InView>\n );\n\n export default Component;\n ```\n\n ## Plain children\n\n You can pass any element to the `<InView />`, and it will handle creating the\n wrapping DOM element. Add a handler to the `onChange` method, and control the\n state in your own component. Any extra props you add to `<InView>` will be\n passed to the HTML element, allowing you set the `className`, `style`, etc.\n\n ```jsx\n import { InView } from 'react-intersection-observer';\n\n const Component = () => (\n <InView as=\"div\" onChange={(inView, entry) => console.log('Inview:', inView)}>\n <h2>Plain children are always rendered. Use onChange to monitor state.</h2>\n </InView>\n );\n\n export default Component;\n ```\n */\nexport class InView extends React.Component<\n  IntersectionObserverProps | PlainChildrenProps,\n  State\n> {\n  constructor(props: IntersectionObserverProps | PlainChildrenProps) {\n    super(props);\n    this.state = {\n      inView: !!props.initialInView,\n      entry: undefined,\n    };\n  }\n\n  componentDidUpdate(prevProps: IntersectionObserverProps) {\n    // If a IntersectionObserver option changed, reinit the observer\n    if (\n      prevProps.rootMargin !== this.props.rootMargin ||\n      prevProps.root !== this.props.root ||\n      prevProps.threshold !== this.props.threshold ||\n      prevProps.skip !== this.props.skip ||\n      prevProps.trackVisibility !== this.props.trackVisibility ||\n      prevProps.delay !== this.props.delay\n    ) {\n      this.unobserve();\n      this.observeNode();\n    }\n  }\n\n  componentWillUnmount() {\n    this.unobserve();\n    this.node = null;\n  }\n\n  node: Element | null = null;\n  _unobserveCb: (() => void) | null = null;\n\n  observeNode() {\n    if (!this.node || this.props.skip) return;\n    const {\n      threshold,\n      root,\n      rootMargin,\n      trackVisibility,\n      delay,\n      fallbackInView,\n    } = this.props;\n\n    this._unobserveCb = observe(\n      this.node,\n      this.handleChange,\n      {\n        threshold,\n        root,\n        rootMargin,\n        // @ts-ignore\n        trackVisibility,\n        // @ts-ignore\n        delay,\n      },\n      fallbackInView,\n    );\n  }\n\n  unobserve() {\n    if (this._unobserveCb) {\n      this._unobserveCb();\n      this._unobserveCb = null;\n    }\n  }\n\n  handleNode = (node?: Element | null) => {\n    if (this.node) {\n      // Clear the old observer, before we start observing a new element\n      this.unobserve();\n\n      if (!node && !this.props.triggerOnce && !this.props.skip) {\n        // Reset the state if we get a new node, and we aren't ignoring updates\n        this.setState({ inView: !!this.props.initialInView, entry: undefined });\n      }\n    }\n\n    this.node = node ? node : null;\n    this.observeNode();\n  };\n\n  handleChange = (inView: boolean, entry: IntersectionObserverEntry) => {\n    if (inView && this.props.triggerOnce) {\n      // If `triggerOnce` is true, we should stop observing the element.\n      this.unobserve();\n    }\n    if (!isPlainChildren(this.props)) {\n      // Store the current State, so we can pass it to the children in the next render update\n      // There's no reason to update the state for plain children, since it's not used in the rendering.\n      this.setState({ inView, entry });\n    }\n    if (this.props.onChange) {\n      // If the user is actively listening for onChange, always trigger it\n      this.props.onChange(inView, entry);\n    }\n  };\n\n  render() {\n    const { children } = this.props;\n    if (typeof children === 'function') {\n      const { inView, entry } = this.state;\n      return children({ inView, entry, ref: this.handleNode });\n    }\n\n    const {\n      as,\n      triggerOnce,\n      threshold,\n      root,\n      rootMargin,\n      onChange,\n      skip,\n      trackVisibility,\n      delay,\n      initialInView,\n      fallbackInView,\n      ...props\n    } = this.props as PlainChildrenProps;\n\n    return React.createElement(\n      as || 'div',\n      { ref: this.handleNode, ...props },\n      children,\n    );\n  }\n}\n","import * as React from 'react';\nimport type { InViewHookResponse, IntersectionOptions } from './index';\nimport { observe } from './observe';\n\ntype State = {\n  inView: boolean;\n  entry?: IntersectionObserverEntry;\n};\n\n/**\n * React Hooks make it easy to monitor the `inView` state of your components. Call\n * the `useInView` hook with the (optional) [options](#options) you need. It will\n * return an array containing a `ref`, the `inView` status and the current\n * [`entry`](https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry).\n * Assign the `ref` to the DOM element you want to monitor, and the hook will\n * report the status.\n *\n * @example\n * ```jsx\n * import React from 'react';\n * import { useInView } from 'react-intersection-observer';\n *\n * const Component = () => {\n *   const { ref, inView, entry } = useInView({\n *       threshold: 0,\n *   });\n *\n *   return (\n *     <div ref={ref}>\n *       <h2>{`Header inside viewport ${inView}.`}</h2>\n *     </div>\n *   );\n * };\n * ```\n */\nexport function useInView({\n  threshold,\n  delay,\n  trackVisibility,\n  rootMargin,\n  root,\n  triggerOnce,\n  skip,\n  initialInView,\n  fallbackInView,\n  onChange,\n}: IntersectionOptions = {}): InViewHookResponse {\n  const [ref, setRef] = React.useState<Element | null>(null);\n  const callback = React.useRef<IntersectionOptions['onChange']>();\n  const [state, setState] = React.useState<State>({\n    inView: !!initialInView,\n    entry: undefined,\n  });\n\n  // Store the onChange callback in a `ref`, so we can access the latest instance\n  // inside the `useEffect`, but without triggering a rerender.\n  callback.current = onChange;\n\n  React.useEffect(\n    () => {\n      // Ensure we have node ref, and that we shouldn't skip observing\n      if (skip || !ref) return;\n\n      let unobserve: (() => void) | undefined;\n      unobserve = observe(\n        ref,\n        (inView, entry) => {\n          setState({\n            inView,\n            entry,\n          });\n          if (callback.current) callback.current(inView, entry);\n\n          if (entry.isIntersecting && triggerOnce && unobserve) {\n            // If it should only trigger once, unobserve the element after it's inView\n            unobserve();\n            unobserve = undefined;\n          }\n        },\n        {\n          root,\n          rootMargin,\n          threshold,\n          // @ts-ignore\n          trackVisibility,\n          // @ts-ignore\n          delay,\n        },\n        fallbackInView,\n      );\n\n      return () => {\n        if (unobserve) {\n          unobserve();\n        }\n      };\n    },\n    // We break the rule here, because we aren't including the actual `threshold` variable\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      // If the threshold is an array, convert it to a string, so it won't change between renders.\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      Array.isArray(threshold) ? threshold.toString() : threshold,\n      ref,\n      root,\n      rootMargin,\n      triggerOnce,\n      skip,\n      trackVisibility,\n      fallbackInView,\n      delay,\n    ],\n  );\n\n  const entryTarget = state.entry?.target;\n  const previousEntryTarget = React.useRef<Element>();\n  if (\n    !ref &&\n    entryTarget &&\n    !triggerOnce &&\n    !skip &&\n    previousEntryTarget.current !== entryTarget\n  ) {\n    // If we don't have a node ref, then reset the state (unless the hook is set to only `triggerOnce` or `skip`)\n    // This ensures we correctly reflect the current state - If you aren't observing anything, then nothing is inView\n    previousEntryTarget.current = entryTarget;\n    setState({\n      inView: !!initialInView,\n      entry: undefined,\n    });\n  }\n\n  const result = [setRef, state.inView, state.entry] as InViewHookResponse;\n\n  // Support object destructuring, by adding the specific values.\n  result.ref = result[0];\n  result.inView = result[1];\n  result.entry = result[2];\n\n  return result;\n}\n"],"names":["_interopRequireDefault","require","exports","_createSvgIcon","_jsxRuntime","_default","default","jsx","d","createSvgIcon","_jsx","self","global","t","f","e","l","Math","abs","n","r","o","i","s","zero","one","two","three","four","five","six","seven","eight","nine","ten","eleven","twelve","h","test","replace","a","p","v","b","y","c","m","w","x","parseInt","TypeError","RangeError","arguments","join","push","floor","M","toOrdinal","String","charAt","length","toWords","toWordsOrdinal","module","numberToWords","VIEWBOX_CENTER_X","VIEWBOX_CENTER_Y","Path","_a","className","counterClockwise","dashRatio","pathRadius","strokeWidth","style","createElement","Object","assign","getDashStyle","getPathDescription","fillOpacity","rotation","diameter","PI","gapLength","strokeDasharray","strokeDashoffset","CircularProgressbar","_super","__extends","prototype","getBackgroundPadding","this","props","background","backgroundPadding","getPathRadius","getPathRatio","value","minValue","maxValue","min","max","render","circleRatio","classes","styles","text","pathRatio","root","viewBox","cx","cy","trail","path","defaultProps","Component","observerMap","Map","RootIds","WeakMap","rootId","unsupportedValue","optionsToId","options","keys","sort","filter","key","map","concat","has","set","toString","get","observe","element","callback","undefined","fallbackInView","window","IntersectionObserver","bounds","getBoundingClientRect","isIntersecting","target","intersectionRatio","threshold","time","boundingClientRect","intersectionRect","rootBounds","id","observer","elements","instance","thresholds","entries","forEach","entry","inView","some","trackVisibility","isVisible","Array","isArray","createObserver","callbacks","splice","indexOf","delete","unobserve","size","disconnect","React","useInView","delay","rootMargin","triggerOnce","skip","initialInView","onChange","ref","setRef","React2","state","setState","current","entryTarget","previousEntryTarget","result"],"sourceRoot":""}